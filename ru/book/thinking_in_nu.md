# Мышление в Nushell

Чтобы помочь вам понять Nushell и извлечь из него максимум пользы, мы подготовили этот раздел, посвященный "мышлению в Nushell". Научившись думать в Nushell и использовать шаблоны, которые он предоставляет, вы столкнетесь с меньшим количеством проблем в начале работы и будете лучше настроены на успех.

Так что же значит думать в Nushell? Вот некоторые общие темы, которые возникают у новых пользователей Nushell.

## Nushell это не bash

Nushell - это не просто шелл, это так-же и язык программирования. Из-за этого он имеет свои способы работы с файлами, дерикториями, веб-сайтами и др. Мы смоделировали его так, чтобы он работал близко к тому, с чем вы можете быть знакомы из других шеллов. Для примера пайплайны работают следующим образом:

```nu
> ls | length
```

В Nushell, например, есть поддержка других распространенных возможностей, таких как получение кода выхода из ранее запущенных команд.

Несмотря на все эти удобства, Nushell - это не bash. Способ работы в bash и стиль POSIX в целом не поддерживается Nushell. Например, в bash вы можете использовать:

```sh
> echo "hello" > output.txt
```

В Nushell мы используем `>` в качестве оператора сравнения. Это лучше согласуется с основными аспектами Nushell. Вместо этого вы можете передать данные по пайплайну в команду, которая сохранит их в файл:

```nu
> "hello" | save output.txt
```

Мышление в Nushell: В Nushell данные рассматриваются так: они проходят через конвейер, пока не попадут к пользователю или не будут обработаны конечной командой. Вы можете просто набирать данные, от строк до списков и записей в стиле JSON, и сопровождать их командами `|` для отправки по конвейеру. Nushell использует команды для выполнения работы и получения большего количества данных. Изучение этих команд и того, когда их следует использовать, поможет вам создать множество видов конвейеров

## Думайте о Nushell как о компилируемом языке

Важной частью дизайна Nushell и его отличием от многих динамических языков является то, что Nushell преобразует исходный текст, который вы ему передаете, в нечто, что нужно выполнить, а затем запускает результат. В нем нет функции `eval`, которая позволяет вам продолжать подтягивать новые исходники во время выполнения. Это означает, что для выполнения таких задач, как включение файлов в проект, необходимо знать пути, подобно тому, как это делается в компилируемых языках, таких как C++ или Rust.

Например, следующая команда не имеет смысла в Nushell и не выполнится, если ее запустить как сценарий:

```nu
"def abc [] { 1 + 2 }" | save output.nu
source "output.nu"
abc
```

Команда [`source`](/commands/docs/source.md) увеличит скомпилированный исходник, но команда [`save`](/commands/docs/save.md) из предыдущей строки не успеет выполниться. Nushell запускает весь блок, как если бы он был одним файлом, а не по одной строке за раз. В примере, поскольку файл output.nu создается только после шага "компиляция", команда [`source`](/commands/docs/source.md) не сможет прочитать из него определения во время разбора.

Еще одна распространенная проблема - попытка динамически создать имя файла для источника:

```nu
> source $"($my_path)/common.nu"
```

Это не работает, если `my_path` является обычной переменной времени выполнения, объявленной с помощью `let`. Это потребовало бы от
evaluator для запуска и оценки строки, но, к сожалению, Nushell нуждается в этой информации во время компиляции.

Однако если `my_path` является [константой](/book/variables#constant-variables), то это
будет работать, поскольку строка может быть оценена во время компиляции:

```nu
> const my_path = ([$nu.home-path nushell] | path join)
> source $"($my_path)/common.nu" # sources /home/user/nushell/common.nu
```

**Мышление в Nushell:** Nushell разработан так, чтобы использовать один шаг компиляции для всех исходных текстов, которые вы ему присылаете, и это отдельно от оценки. Это позволит обеспечить сильную поддержку IDE, точные сообщения об ошибках, более простой язык для работы со сторонними инструментами, а в будущем и более сложные результаты, например, возможность компилировать Nushell непосредственно в бинарный файл.

Для более подробной информации смотрите: [How Nushell Code Gets Run](how_nushell_code_gets_run.md).

## Переменные по умолчанию неизменяемы

Другой распространенной неожиданностью для людей, пришедших из других языков, является то, что переменные Nushell по умолчанию неизменяемы. Приходя в Nushell, вы захотите потратить некоторое время на знакомство с более функциональным стилем работы, поскольку это, как правило, помогает писать код, который лучше всего работает с неизменяемыми переменными.

**Мышление в Nushell:** Если вы привыкли использовать изменяемые переменные для различных задач, вам потребуется некоторое время, чтобы научиться выполнять каждую задачу в более функциональном стиле. В Nushell есть набор встроенных возможностей для решения многих из этих задач, и их изучение поможет вам писать код в более Nushell-стиле. Приятным бонусом будет ускорение работы ваших скриптов за счет параллельного выполнения частей кода.

Дополнительную информацию см. в разделах [Неизменяемые переменные](variables.html#immutable-variables) и [Выбор между изменяемыми и неизменяемыми переменными](variables.html#choosing-between-mutable-and-immutable-variables).

## Окружающая среда Nushell является обширной

Nushell берет несколько примеров дизайна из компилируемых языков. Один из них заключается в том, что языки должны избегать глобального изменяемого состояния. В оболочках обычно используется глобальная мутация для обновления окружения, но Nushell избегает этого подхода.

В Nushell блоки контролируют свое собственное окружение. Изменения окружения привязаны к блоку, в котором они происходят.

На практике это позволяет написать лаконичный код для работы с подкаталогами, например, если вы хотите собрать каждый подпроект в текущем каталоге, вы можете выполнить команду:

```nu
> ls | each { |it|
    cd $it.name
    make
}
```

Команда [`cd`](/commands/docs/cd.md) изменяет переменные окружения `PWD`, и это изменение переменных не выходит за пределы блока, позволяя каждой итерации начинать с текущего каталога и переходить в следующий подкаталог.

Подобное расположение переменных окружения делает команды более предсказуемыми, их легче читать, а когда приходит время, легче отлаживать. Nushell также предоставляет вспомогательные команды, такие как [`def --env`](/commands/docs/def.md), [`load-env`](/commands/docs/load-env.md), как удобные способы выполнения пакетных обновлений окружения.

Исключение составляет команда [`def --env`](/commands/docs/def.md), позволяющая создать команду, которая участвует в окружении вызывающей стороны.\_

**Мышление в Nushell:** - Лучшая практика кодирования, заключающаяся в отсутствии глобальных изменяемых переменных, распространяется и на окружение в Nushell. Использование встроенных команд-помощников позволит вам легче работать с окружением в Nushell. Использование того факта, что окружения привязаны к блокам, также поможет вам писать более лаконичные скрипты и взаимодействовать с внешними командами, не добавляя в глобальное окружение ненужных вещей.
