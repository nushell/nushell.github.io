# 加载数据

之前我们使用了[`ls`](/commands/docs/ls.md)、[`ps`](/commands/docs/ps.md)、[`date`](/commands/docs/date.md)和[`sys`](/commands/docs/sys.md)等命令来加载关于文件、进程、日期时间和系统本身的信息。每条命令都会给我们提供一个信息表，以对其进行探索。我们也可以通过其他方式将数据载入表格以供使用。

## 打开文件

Nu 在处理数据方面最强大的能力之一是[`open`](/commands/docs/open.md)命令。它是一个多功能命令，可以处理许多不同的数据格式。为了说明这一点让我们试着打开一个 JSON 文件：

@[code](@snippets/loading_data/vscode.sh)

与[`ls`](/commands/docs/ls.md)类似，打开一个 Nu 支持的文件类型，会返回一些不仅仅是文本（或一个字节流）的东西。这里我们打开了一个来自 JavaScript 项目的 "package.json" 文件。Nu 可以识别 JSON 文本并将其解析为一个数据表。

如果我们想查看当前项目的版本，我们可以使用[`get`](/commands/docs/get.md)命令：

```nu
open editors/vscode/package.json | get version
# => 1.0.0
```

Nu 目前支持直接从以下格式加载表数据：

- csv
- eml
- ics
- ini
- json
- nuon
- ods
- ssv
- toml
- tsv
- url
- vcf
- xlsx / xls
- xml
- yaml / yml

但是，当你加载其他的文本文件时会发生什么呢？让我们试一试：

```nu
open README.md
```

我们会看到该文件的内容。

本质上，这些文本文件对 Nu 来说就是一个大字符串。接下来，我们将讨论如何处理这些字符串，以便从中获得我们需要的数据。

## 处理字符串

处理来自 Nu 外部数据时一个普遍情况是，它并不总是以 Nu 理解的格式出现。通常这些数据是以字符串的形式提供给我们的。

想象一下，我们得到了这个数据文件：

```nu
open people.txt
# => Octavia | Butler | Writer
# => Bob | Ross | Painter
# => Antonio | Vivaldi | Composer
```

我们想要的数据都由管道（`|`）符号隔开，每人单独一行。由于 Nu 没有默认的以管道分隔的文件格式，所以我们必须自己来解析。

当我们引入这个文件时，我们需要做的第一件事是确保后续每次只处理一行：

```nu
open people.txt | lines
# => ───┬──────────────────────────────
# =>  0 │ Octavia | Butler | Writer
# =>  1 │ Bob | Ross | Painter
# =>  2 │ Antonio | Vivaldi | Composer
# => ───┴──────────────────────────────
```

可以看到，我们正在处理这些行，因为我们又回到了一个列表中。下一步是看看是否可以把行分割成更有用的东西。为此，我们将使用[`split`](/commands/docs/split.md)命令。[`split`](/commands/docs/split.md)，顾名思义，为我们提供了一种分割字符串的方法。我们将使用[`split`](/commands/docs/split.md)的`column`子命令，将内容分成多列。我们会告诉它分隔符是什么，剩下的就由它来完成：

```nu
open people.txt | lines | split column "|"
# => ───┬──────────┬───────────┬───────────
# =>  # │ column1  │ column2   │ column3
# => ───┼──────────┼───────────┼───────────
# =>  0 │ Octavia  │  Butler   │  Writer
# =>  1 │ Bob      │  Ross     │  Painter
# =>  2 │ Antonio  │  Vivaldi  │  Composer
# => ───┴──────────┴───────────┴───────────
```

这看起来差不多了，只是还有一些额外的空白字符，让我们 [`trim`](/commands/docs/str_trim.md) 掉这些空格：

```nu
open people.txt | lines | split column "|" | str trim
# => ───┬─────────┬─────────┬──────────
# =>  # │ column1 │ column2 │ column3
# => ───┼─────────┼─────────┼──────────
# =>  0 │ Octavia │ Butler  │ Writer
# =>  1 │ Bob     │ Ross    │ Painter
# =>  2 │ Antonio │ Vivaldi │ Composer
# => ───┴─────────┴─────────┴──────────
```

还不错，[`split`](/commands/docs/split.md)命令返回给我们可以使用的数据，还预设了默认的列名：

```nu
open people.txt | lines | split column "|" | str trim | get column1
# => ───┬─────────
# =>  0 │ Octavia
# =>  1 │ Bob
# =>  2 │ Antonio
# => ───┴─────────
```

我们也可以用自定义的列名代替默认的：

```nu
open people.txt | lines | split column "|" first_name last_name job | str trim
# => ───┬────────────┬───────────┬──────────
# =>  # │ first_name │ last_name │ job
# => ───┼────────────┼───────────┼──────────
# =>  0 │ Octavia    │ Butler    │ Writer
# =>  1 │ Bob        │ Ross      │ Painter
# =>  2 │ Antonio    │ Vivaldi   │ Composer
# => ───┴────────────┴───────────┴──────────
```

现在，我们的数据加载到一个表中了，我们可以使用之前对表所用的各种命令来处理它：

```nu
open people.txt | lines | split column "|" first_name last_name job | str trim | sort-by first_name
# => ───┬────────────┬───────────┬──────────
# =>  # │ first_name │ last_name │ job
# => ───┼────────────┼───────────┼──────────
# =>  0 │ Antonio    │ Vivaldi   │ Composer
# =>  1 │ Bob        │ Ross      │ Painter
# =>  2 │ Octavia    │ Butler    │ Writer
# => ───┴────────────┴───────────┴──────────
```

其他可用于字符串的命令有：

- `str`
- [`lines`](/commands/docs/lines.md)
- ~~`size`~~

如果我们已经知道待处理的数据具有 Nu 能够理解的格式，则可以使用一些辅助命令，例如，我们打开一个 Rust 的 Cargo.lock 文件：

```toml
open Cargo.lock
# => # This file is automatically @generated by Cargo.
# => # It is not intended for manual editing.
# => [[package]]
# => name = "adhoc_derive"
# => version = "0.1.2"
```

"Cargo.lock" 实际上是一个 .toml 文件，但是文件扩展名不是 .toml。没关系，我们可以使用 `from toml` 命令：

@[code](@snippets/loading_data/cargo-toml.sh)

每种 Nu 能打开并理解的结构化数据文本格式都有对应的 `from` 命令可以使用，只需要把支持的格式作为子命令传给 `from` 就可以了。

## 以原始模式打开

虽然能够打开一个文件并立即使用其数据表很有帮助，但这并不总是我们想要的。为了获得原始文本，[`open`](/commands/docs/open.md)命令可以接受一个可选的`--raw`标志：

```toml
open Cargo.toml --raw
# => [package]
# => name = "nu"
# => version = "0.1.3"
# => authors = ["Yehuda Katz <wycats@gmail.com>", "Sophia Turner <547158+sophiajt@users.noreply.github.com>"]
# => description = "A shell for the GitHub era"
# => license = "MIT"
```

## 获取 URLs

除了从文件系统中加载文件，你还可以通过使用[`http get`](/commands/docs/http_get.md)命令来加载 URLs。这将从互联网上获取 URL 的内容并返回：

@[code](@snippets/loading_data/rust-lang-feed.sh)
