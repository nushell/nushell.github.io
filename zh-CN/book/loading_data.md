# 加载数据

之前我们使用了[`ls`](/commands/docs/ls.md)、[`ps`](/commands/docs/ps.md)、[`date`](/commands/docs/date.md)和[`sys`](/commands/docs/sys.md)等命令来加载关于文件、进程、日期时间和系统本身的信息。每条命令都会给我们提供一个信息表，以对其进行探索。我们也可以通过其他方式将数据载入表格以供使用。

## 打开文件

Nu 在处理数据方面最强大的能力之一是[`open`](/commands/docs/open.md)命令。它是一个多功能命令，可以处理许多不同的数据格式。为了说明这一点让我们试着打开一个 JSON 文件：

@[code](@snippets/loading_data/vscode.sh)

与[`ls`](/commands/docs/ls.md)类似，打开一个 Nu 支持的文件类型，会返回一些不仅仅是文本（或一个字节流）的东西。这里我们打开了一个来自 JavaScript 项目的 "package.json" 文件。Nu 可以识别 JSON 文本并将其解析为一个数据表。

如果我们想查看当前项目的版本，我们可以使用[`get`](/commands/docs/get.md)命令：

```nu
open editors/vscode/package.json | get version
# => 1.0.0
```

Nu 目前支持直接从以下格式加载表数据：

- csv
- eml
- ics
- ini
- json
- [nuon](#nuon)
- ods
- [SQLite 数据库](#sqlite)
- ssv
- toml
- tsv
- url
- vcf
- xlsx / xls
- xml
- yaml / yml

::: tip 你知道吗？
在底层，`open` 会在你的作用域中查找与文件扩展名匹配的 `from ...` 子命令。
因此，你可以通过创建自己的 `from ...` 子命令来简单地扩展 `open` 支持的文件类型集。
:::

但是，当你加载其他的文本文件时会发生什么呢？让我们试一试：

```nu
open README.md
```

我们会看到该文件的内容。

本质上，这些文本文件对 Nu 来说就是一个大字符串。接下来，我们将讨论如何处理这些字符串，以便从中获得我们需要的数据。

## NUON

Nushell 对象表示法（Nushell Object Notation，NUON）旨在成为 Nushell 的 JavaScript 对象表示法（JavaScript Object Notation，JSON）。
也就是说，NUON 代码是描述某种数据结构的有效 Nushell 代码。
例如，这是一个有效的 NUON（示例来自[默认配置文件](https://github.com/nushell/nushell/blob/main/crates/nu-utils/src/default_files/default_config.nu)）：

```nu
{
  menus: [
    # 默认 nushell 菜单的配置
    # 注意缺少 source 参数
    {
      name: completion_menu
      only_buffer_difference: false
      marker: "| "
      type: {
          layout: columnar
          columns: 4
          col_width: 20   # 可选值。如果缺少，则使用所有屏幕宽度来计算列宽
          col_padding: 2
      }
      style: {
          text: green
          selected_text: green_reverse
          description_text: yellow
      }
    }
  ]
}
```

你可能会注意到它与 JSON 非常相似，你是对的。
**NUON 是 JSON 的超集！**
也就是说，任何 JSON 代码都是有效的 NUON 代码，因此也是有效的 Nushell 代码。
与 JSON 相比，NUON 更“人性化”。
例如，允许注释，并且不需要逗号。

目前 NUON 的一个限制是它不能表示所有的 Nushell [数据类型](types_of_data.md)。
最值得注意的是，NUON 不允许序列化代码块。

## 处理字符串

处理来自 Nu 外部数据时一个普遍情况是，它并不总是以 Nu 理解的格式出现。通常这些数据是以字符串的形式提供给我们的。

想象一下，我们得到了这个数据文件：

```nu
open people.txt
# => Octavia | Butler | Writer
# => Bob | Ross | Painter
# => Antonio | Vivaldi | Composer
```

我们想要的数据都由管道（`|`）符号隔开，每人单独一行。由于 Nu 没有默认的以管道分隔的文件格式，所以我们必须自己来解析。

当我们引入这个文件时，我们需要做的第一件事是确保后续每次只处理一行：

```nu
open people.txt | lines
# => ───┬──────────────────────────────
# =>  0 │ Octavia | Butler | Writer
# =>  1 │ Bob | Ross | Painter
# =>  2 │ Antonio | Vivaldi | Composer
# => ───┴──────────────────────────────
```

可以看到，我们正在处理这些行，因为我们又回到了一个列表中。下一步是看看是否可以把行分割成更有用的东西。为此，我们将使用[`split`](/commands/docs/split.md)命令。[`split`](/commands/docs/split.md)，顾名思义，为我们提供了一种分割字符串的方法。我们将使用[`split`](/commands/docs/split.md)的`column`子命令，将内容分成多列。我们会告诉它分隔符是什么，剩下的就由它来完成：

```nu
open people.txt | lines | split column "|"
# => ───┬──────────┬───────────┬───────────
# =>  # │ column1  │ column2   │ column3
# => ───┼──────────┼───────────┼───────────
# =>  0 │ Octavia  │  Butler   │  Writer
# =>  1 │ Bob      │  Ross     │  Painter
# =>  2 │ Antonio  │  Vivaldi  │  Composer
# => ───┴──────────┴───────────┴───────────
```

这看起来差不多了，只是还有一些额外的空白字符，让我们 [`trim`](/commands/docs/str_trim.md) 掉这些空格：

```nu
open people.txt | lines | split column "|" | str trim
# => ───┬─────────┬─────────┬──────────
# =>  # │ column1 │ column2 │ column3
# => ───┼─────────┼─────────┼──────────
# =>  0 │ Octavia │ Butler  │ Writer
# =>  1 │ Bob     │ Ross    │ Painter
# =>  2 │ Antonio │ Vivaldi │ Composer
# => ───┴─────────┴─────────┴──────────
```

还不错，[`split`](/commands/docs/split.md)命令返回给我们可以使用的数据，还预设了默认的列名：

```nu
open people.txt | lines | split column "|" | str trim | get column1
# => ───┬─────────
# =>  0 │ Octavia
# =>  1 │ Bob
# =>  2 │ Antonio
# => ───┴─────────
```

我们也可以用自定义的列名代替默认的：

```nu
open people.txt | lines | split column "|" first_name last_name job | str trim
# => ───┬────────────┬───────────┬──────────
# =>  # │ first_name │ last_name │ job
# => ───┼────────────┼───────────┼──────────
# =>  0 │ Octavia    │ Butler    │ Writer
# =>  1 │ Bob        │ Ross      │ Painter
# =>  2 │ Antonio    │ Vivaldi   │ Composer
# => ───┴────────────┴───────────┴──────────
```

现在，我们的数据加载到一个表中了，我们可以使用之前对表所用的各种命令来处理它：

```nu
open people.txt | lines | split column "|" first_name last_name job | str trim | sort-by first_name
# => ───┬────────────┬───────────┬──────────
# =>  # │ first_name │ last_name │ job
# => ───┼────────────┼───────────┼──────────
# =>  0 │ Antonio    │ Vivaldi   │ Composer
# =>  1 │ Bob        │ Ross      │ Painter
# =>  2 │ Octavia    │ Butler    │ Writer
# => ───┴────────────┴───────────┴──────────
```

其他可用于字符串的命令有：

- [`str`](/commands/docs/str.md)
- [`lines`](/commands/docs/lines.md)

如果我们已经知道待处理的数据具有 Nu 能够理解的格式，则可以使用一些辅助命令，例如，我们打开一个 Rust 的 Cargo.lock 文件：

```nu
open Cargo.lock
# => # This file is automatically @generated by Cargo.
# => # It is not intended for manual editing.
# => [[package]]
# => name = "adhoc_derive"
# => version = "0.1.2"
```

"Cargo.lock" 实际上是一个 .toml 文件，但是文件扩展名不是 .toml。没关系，我们可以使用 `from` 命令和 `toml` 子命令：

@[code](@snippets/loading_data/cargo-toml.sh)

每种 Nu 能打开并理解的结构化数据文本格式都有对应的 `from` 命令可以使用，只需要把支持的格式作为子命令传给 `from` 就可以了。

## 以原始模式打开

虽然能够打开一个文件并立即使用其数据表很有帮助，但这并不总是我们想要的。为了获得原始文本，[`open`](/commands/docs/open.md)命令可以接受一个可选的`--raw`标志：

```nu
open Cargo.toml --raw
# => [package]                                                                                        name = "nu"
# => version = "0.1.3"
# => authors = ["Yehuda Katz <wycats@gmail.com>", "Sophia Turner <547158+sophiajt@users.noreply.github.com>"]
# => description = "A shell for the GitHub era"
# => license = "MIT"
```

## SQLite

SQLite 数据库会被 [`open`](/commands/docs/open.md) 自动检测，无论其文件扩展名是什么。你可以打开整个数据库：

```nu
open foo.db
```

或者 [`get`](/commands/docs/get.md) 一个特定的表：

```nu
open foo.db | get some_table
```

或者运行任何你喜欢的 SQL 查询：

```nu
open foo.db | query db "select * from some_table"
```

（注意：一些旧版本的 Nu 使用 `into db | query` 而不是 `query db`）

## 获取 URLs

除了从文件系统中加载文件，你还可以通过使用[`http get`](/commands/docs/http.md)命令来加载 URLs。这将从互联网上获取 URL 的内容并返回：

@[code](@snippets/loading_data/rust-lang-feed.sh)
