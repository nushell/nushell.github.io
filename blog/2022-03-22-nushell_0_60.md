---
title: Nushell 0.60
author: The Nu Authors
author_site: https://twitter.com/nu_shell
author_image: https://www.nushell.sh/blog/images/nu_logo.png
excerpt: Today, we're releasing version 0.60 of Nu. This is an enormous release, with lots of changes across all aspects of Nushell.
---

TODO:

- animation gif?
- fill out custom completions section
- document def-env and scoped `cd`
- ~~document parallelism and `par-each`~~
- document `extern`
- more typechecking
- engine and storing spans
- faster parsing, faster engine
- ~~correct variable captures~~
- ~~add screenshot for lscolors support~~
- ~~document breaking changes~~
- default params/flags
- ~~add peoples names who worked on various part~~
- ~~or... thank everyone who worked on this release~~
- reedline
  - entirely new keybinding system
- ~~$env.PROMPT_COMMAND and $env.PROMPT_COMMAND_RIGHT with block or string~~
- ~~$env.LAST_EXIT_CODE~~
- ~~size of binaries down 10x~~
- scoped cd
- ability to page data with ls + less
- ~~$env.LS_COLORS~~
- ~~footers in tables~~
- ~~maybe a list of new commands~~
  - ~~columns~~
  - ~~complete~~
  - ~~decode~~
  - ~~def-env~~
  - ~~env~~
  - ~~export, export def, export env~~
  - ~~extern~~
  - ~~fmt~~
  - ~~group~~
  - ~~grid, as in, alias lsg = ls | grid -c~~
  - ~~gstat plugin~~
  - ~~ignore~~
  - ~~keybindings default, keybindings listen, keybindings list~~
  - ~~module~~
  - ~~nu-highlight~~
  - ~~par-each~~
  - ~~print~~
  - ~~register~~
  - ~~transpose~~
  - ~~use~~
  - ~~window~~
  - ~~view-source~~

# Nushell 0.60

Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines.

Today, we're releasing a beta release of 0.60 of Nu. This is an enormous release, with lots of changes across all aspects of Nushell.

<!-- more -->

# Where to get it

Nu 0.60 is available as [pre-built binaries](https://github.com/nushell/nushell/releases/tag/0.60.0) or from [crates.io](https://crates.io/crates/nu). If you have Rust installed you can install it using `cargo install nu`.

If you want all the built-in goodies, you can install `cargo install nu --all-features`.

As part of this release, we also publish a set of optional plugins you can install and use with Nu. To install, use `cargo install nu_plugin_<plugin name>`.

# Party! ðŸ¥³

It's here! ðŸŽ‰ðŸŽ‰

We're excited to announce the first full release of Nushell using the new engine, new line editor, and so much more. In this blog post, we'll detail the new capabilities.

# Jumping versions

The first thing you'll notice is that we're jumping from version 0.44 to 0.60. This is on purpose, you didn't miss anything.

Because of the number of changes, and the number of breaking changes, we wanted to let everyone know how much had changed by also making a big jump in the version number. Previous scripts will need to be updated, and you'll need to learn some of the new ways of doing things in Nushell to get back to your same level of comfort.

Let's talk about the features new in this release.

# Custom completions

Let's not bury the lede. The long-awaited, long-requested feature of having nice completions is finally here. With 0.60, you'll be able to write scripts that help you complete parameters and flag values. Let's take a look at an example. When you create a new config, you'll see this section:

```
# This is a simplified version of completions for git branches and git remotes
def "nu-complete git branches" [] {
  ^git branch | lines | each { |line| $line | str find-replace '\* ' '' | str trim }
}

def "nu-complete git remotes" [] {
  ^git remote | lines | each { |line| $line | str trim }
}
```

To call these function at the right time, we need to tell Nushell which parameter can complete with them.

```
extern "git checkout" [
  branch?: string@"nu-complete git branches" # name of the branch to checkout
  -b: string                                 # create and checkout a new branch
  -B: string                                 # create/reset and checkout a branch
  # note: other parameters removed for brevity
]
```

The `@` followed by the name of the completion function tells the completer what command to call to get a list of completions to use in that position, and you can down-select from these.

We've already seen early adopters starting to write their own completions for other commands, and are excited to see what people will do.

# A new config file

With 0.60, we've moved away from the .toml style of config to a config built from a Nushell script. We've found this to be both more intuitive and much easier to work with.

When you first start up Nushell, you'll be asked if you'd like to create a default config file. This is a great way to see the new defaults and to change them to meet your needs. You'll also see some examples in how to modify the stylings, prompt, keybindings, and external completions.

# Language improvements

There's quite a list of changes to the language itself. Let's talk about each one to help you transition to the new Nushell:

## if, meet else

We've improved the syntax of Nushell in a few key places. Previously, in 0.44 you'd write:

```
> if $x < 3 { echo "true!" } { echo "false" }
```

This not only felt inelegant, but was prone to errors as people would want to leave off the second block when they didn't need it or just naturally want to type `else`.

This led to a new concept in Nushell: the keyword shape. Shapes in Nushell are a way for commands to tell the parser what the shape of their parameters are. In turn, the parser will use this knowledge to parse the arguments before they're given to the command (and also to do completions and early errors). With this, `else` is now one of the new keyword shapes, allowing it to take an expression that follows.

Taken together, in 0.60 we can now not only write the above like this:

```
if $x < 3 {
  echo $true
} else {
  echo $false
}
```

We can also string together multiple if/else:

```
if $x < 3 {
  echo "less than three"
} else if $x < 10 {
  echo "less than ten
} else {
  echo "something else!"
}
```

## Shortcircuiting conditions

Boolean operators `&&` and `||` now will properly shortcircuit, only evaluating the right hand side if necessary.

## Escape characters in strings

With 0.60, Nushell now divides strings into two types: strings with escape characters and strings without. The escaping case is written with double-quotes (`"`) and the non-escaping case is written with single-quotes (`'`):

```
> "hello\world"
hello
world
> 'hello\nworld'
hello\nworld
```

Nushell will prefer the single-quotes for things like path names that include spaces, allowing you to naturally write paths for Windows as well.

The difference in double-quoted and single-quoted strings also extends to interpolated strings (`$""` and `$''`):

```
> let x = 100
> $"value is:\n($x)"
value is:
100
> $'value is:\n($x)'
value is:\n100
```

## New value forms

The 0.60 release also brings with it a number of new value forms.

### Records

You now can write a record, or a list of key/value pairs, as a native data type in Nushell:

```
> {name: "Bob", age: 10}
â•­â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•®
â”‚ name â”‚ Bob â”‚
â”‚ age  â”‚ 10  â”‚
â•°â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â•¯
```

### Table as a list of records

With the introduction of records, a second way to define a table is a list (or stream) of records:

```
> seq 3 | each { |x| { name: Bob, x: $x } }
  #   name   x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0   Bob    1
  1   Bob    2
  2   Bob    3
```

### Integers are now signed 64-bit integers

We're moving away from the 'bigint' style of integers, so now integers are always signed 64-bit ints.

### Decimals are now signed 64-bit floats

Likewise, we're moving away from 'bigdecimal' to signed 64-bit float values.

### Dates

Earlier versions of Nushell supported dates as a value type, but they lacked a way to write them. You can now write a date literal in one of three ways:

```
# As a date
> 2022-02-02

# As a date and time, assuming UTC
> 2022-02-23T19:47:47

# As a date and time, with a timezone
2022-02-23T19:47:47.888239621-05:00
```

These come from the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) standard for datetime formats.

### Binary data

Like dates, earlier versions of Nushell also supported binary data but there was no way to write a binary data literal. You're now able to write them using the `0x[...]` form:

```
> 0x[11 ff]
Length: 2 (0x2) bytes | printable whitespace ascii_other non_ascii
00000000:   11 ff                                                â€¢Ã—
```

Spaces and commas are optional in this form, letting you separate write them however is best for readability.

### Custom values

Another form we'll be talking about more as it grows is the "custom value" form. These are value types that you can extend the current set with by implementing a trait in Rust and registering the type.

The dataframe support in 0.60 uses this feature.

## New built-in values

We're introducing `true` and `false` as builtin values. These represent their boolean values true and false respectively.

## Better binary data support

You can now use `get`, `skip`, and `first` on binary data to reach the bytes you'd like to work with. We're exploring extending this further so that it becomes easier to explore your binary data just like your text data.

## Structured environment

Inside of Nu, the environment can now hold any kind of structured value. For example, opening the `PATH` environment variable now might look like in macOS:

```
> $env.PATH
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ 0 â”‚ /opt/homebrew/opt/openssl@3/bin â”‚
â”‚ 1 â”‚ /opt/homebrew/bin               â”‚
â”‚ 2 â”‚ /opt/homebrew/sbin              â”‚
â”‚ 3 â”‚ /usr/local/bin                  â”‚
â”‚ 4 â”‚ /usr/bin                        â”‚
â”‚ 5 â”‚ /bin                            â”‚
â”‚ 6 â”‚ /usr/sbin                       â”‚
â”‚ 7 â”‚ /sbin                           â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

This allows you to more easily add and update to the environment. For example, we can add a new entry to the PATH:

```
> let-env PATH = ($env.path | prepend '/my/path')
```

Environment variables that aren't strings can be converted to strings automatically using the new `ENV_CONVERSIONS` environment variable.

## More consistent tables and cell paths

With this release, we've simplified the commands for working with tables. The two fundamental commands are now: `select` and `get`.

### `Select`-ing data

The `select` command allows you to keep the structure of what you're working on and reduce it to only the part you want. For example, just as before you can pass `select` to get a column:

```
> ls | select name
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ #  â”‚       name        â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0 â”‚ CNAME             â”‚
â”‚  1 â”‚ CONTRIBUTING.md   â”‚
â”‚  2 â”‚ LICENSE           â”‚
â”‚  3 â”‚ README.md         â”‚
â”‚  4 â”‚ assets            â”‚
â”‚  5 â”‚ blog              â”‚
...
```

You can now also use `select` on rows, by passing in a row number:

```
> ls | select 1
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ # â”‚      name       â”‚ type â”‚ size  â”‚  modified  â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0 â”‚ CONTRIBUTING.md â”‚ file â”‚ 389 B â”‚ 2 days ago â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### `Get`-ing data

The other fundamental command for working with tables is `get`. Like `select`, `get` allows you to work with columns and rows in a table, or fields in a record. Unlike `select`, the `get` command extracts data out of the table and does not try to preserve its original form. This is helpful when you want to get at the cell data itself.

Via a column:

```
> ls | get name
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  0 â”‚ CNAME             â”‚
â”‚  1 â”‚ CONTRIBUTING.md   â”‚
â”‚  2 â”‚ LICENSE           â”‚
â”‚  3 â”‚ README.md         â”‚
â”‚  4 â”‚ assets            â”‚
â”‚  5 â”‚ blog              â”‚
...
```

Via a row:

```
> ls | get 1
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ name     â”‚ CONTRIBUTING.md â”‚
â”‚ type     â”‚ file            â”‚
â”‚ size     â”‚ 389 B           â”‚
â”‚ modified â”‚ 2 days ago      â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

You'll notice that getting rows out of a table with columns gives you back a record. You can think of a table as a list of records.

You can combine working with rows and columns together into a "cell path", a way of reaching the data you want. If we only wanted to get the cell's data in row 1, column "size", we can do:

```
> ls | get size.1
```

## New pipeline syntax form

When writing scripts in Nushell, often folks want to be able to build up a pipeline and line up all the pipes on the left. This is now supported in scripts:

```
ls
| where size > 10kb
| length
```

## Default params

A common request as more people tried Nushell was "can we have default values for parameters". Thanks to the work on the new parser, we can!

Now, you're able to set a default value for any optional parameter in your command:

```
def add-maybe-hundred [x:int, y = 100] {
  $x + $y
}

let twelve_squared = add-maybe-hundred 44
```

Default values also work for flag parameters.

## Stdout, stderr, and exit codes

In previous versions of Nushell, you generally had easy access to the stdout of an external command. You could run it, and then create a pipe and work with its output. If you wanted to work with stderr or get its exit code, you didn't have an easy way to do it.

With 0.60, we've introduced the `complete` command. Running an external command and then pipeline it to `complete` runs the external to completion and then gives you the stdout, stderr, and exit code of that external.

```
> cat CNAME | complete
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ stdout    â”‚ www.nushell.sh â”‚
â”‚ stderr    â”‚                â”‚
â”‚ exit_code â”‚ 0              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

## Modules

With 0.60, you're now able to create your own modules, allowing you to grow to larger projects with clean interfaces between files. A module can be written either using the `module` keyword:

```
module greetings {
  export def greet [] {
    print "hello!"
  }
}

use greetings greet
greet
```

You can also make modules from whole files. We can rewrite the above using a separate file:

```
# greetings.nu
export def greet [] {
  print "hello!"
}

# main.nu
use greetings.nu greet
greet
```

Modules allow you to `export` custom commands and environment variables to be used in other places.

## Make your own errors

You can also create your own error messages in your custom commands and send these back to the user if they call your command in the wrong way. For example, let's say you wanted to require that the user pass in a value between 1 and 10:

```
> def one-to-ten [x: int] {
    let span = (metadata $x).span
    if $x > 10 || $x < 1 {
      error make {
        msg: "Value not between 1 and 10",
        label: {
          text: "expected a value between 1 and 10",
          start: $span.start,
          end: $span.end
        }
      }
    } else {
      $"passed ($x)"
    }
  }
> one-to-ten 6
passed 6
> one-to-ten 21
Error:
  Ã— Value too large
   â•­â”€[entry #47:1:1]
 1 â”‚ one-to-ten 21
   Â·            â”€â”¬
   Â·             â•°â”€â”€ expected a value between 1 and 10
   â•°â”€â”€â”€â”€
```

# Shell improvements

## Bang bang and more

You can now use `!!` to run the previous command, or `!` followed by the row number in the `history` you'd like to run again.

We're working to bring the [book up to date](https://www.nushell.sh/book/), and it's a good place to find explanations of these improvements. Be sure to also look at the [updated command documentation](https://www.nushell.sh/book/command_reference.html) for more information on the updated commands.

## Better multiline editing

![Commands menu](../assets/images/0_59_1_for_multiline_indicator.png)

With the switch to reedline, you can also get better feedback when working on multiline edits. For example, moving to the next line, you'll now see `:::` by default preceding the extended input:

```
> do {
::: echo "hello"
::: echo "world"
::: }
hello
world
```

You can configure the `:::` default value by setting the `PROMPT_MULTILINE_INDICATOR` environment variable. For example, the above screenshot uses ANSI to give it a bit of flare.

## Miette

We're moving to a new error reporter called [miette](https://github.com/zkat/miette). It's an attractive way of showing errors back while you're working in the REPL or on scripts.

```
> 10 / "bob"
Error: nu::parser::unsupported_operation (link)

  Ã— Types mismatched for operation.
   â•­â”€[entry #39:1:1]
 1 â”‚ 10 / "bob"
   Â· â”€â”¬ â”¬ â”€â”€â”¬â”€â”€
   Â·  â”‚ â”‚   â•°â”€â”€ string
   Â·  â”‚ â•°â”€â”€ doesn't support these values.
   Â·  â•°â”€â”€ int
   â•°â”€â”€â”€â”€
  help: Change int or string to be the right types and try again.
```

# Reedline

Nushell has changed its line editor and now it uses [Reedline](https://github.com/nushell/reedline). This new line
editor allows for improvements and added functionality to the already awesome Nushell experience. Some of the
new improvements are:

## Completions menus

![Commands menu](../assets/images/0_60_0_completions_internal.gif)

Do you want to search for commands using a menu? Nushell has you covered.
Press tab and a completion menu will appear with options for you to select. Based on the context different
options will be available to you

## History menu

![History menu](../assets/images/0_60_0_history.gif)

Your shell history can be easily accessed as well via menus. Using ctrl-x, you can search for a
history item or you could just simply navigate the menu until you find what you are looking for.

You can also use the history menu to compose a pipe with smaller pipes you have used before.

![History complete](../assets/images/0_60_0_history_complete.gif)

## New Keybindings

Now you can define complex keybindings for nushell. For example, say you have changed your config file and
want to reload it in your nushell session. You can create a special keybinding to help reload your config file:

```
{
    name: reload_config
    modifier: none
    keycode: f5
    mode: emacs
    event: [
        { edit: { cmd: clear } }
        { edit: { cmd: insertString value: $"source '($nu.config-path)'" } }
        { send: Enter }
    ]
}
```

with this keybinding every time you press F5 you config file is sourced and ready to go. Neat!

# Introducing 'nuon'

As the syntax for Nushell has continued to grow and evolved, we noticed that writing data in Nushell was kinda fun. The more we played with it, the more the idea grew that we could create a data file format using the Nushell syntax for data. Thus, 'nuon' was born. With it, we now include `from nuon` and `to nuon` to help you work with the new .nuon files.

Nuon is a superset of JSON, allowing you to pass JSON files and parse them as nuon. Additionally, Nuon supports the data forms from Nushell, including compact tables, durations, filesizes, and more.

```
# sample.nuon
[
    # The nuon compact table format
    [[a, nuon, table]; [1, 2, 3], [4, 5, 6]],

    # A filesize
    100kib,

    # A duration
    100sec,

    # A date
    2022-01-11,

    # A boolean
    true,

    # A record
    {name: "Bobby", age: 99},

    # Binary data
    0x[11, ff, ee, 1f]
]
```

Nuon is still very much experimental, but we're already enjoying using it and are eager to continue to improve on it.

# Smaller release size

The 0.60 release is significantly smaller than the previous 0.44 release. 

| release file for 0.44.0 | size    |
| ----------------------- | ------- |
| nu_0_44_0_linux.tar.gz  | 103 MB  |
| nu_0_44_0_macOS.zip     | 79.7 MB |
| nu_0_44_0_windows.msi   | 55.5 MB |
| nu_0_44_0_windows.zip   | 57.9 MB |

| release file for 0.60.0 | size    |
| ----------------------- | ------- |
| nu_0_60_0_linux.tar.gz  | 14.8 MB |
| nu_0_60_0_macOS.zip     | 12.9 MB |
| nu_0_60_0_windows.msi   | 10.1 MB |
| nu_0_60_0_windows.zip   | 10.1 MB |

# New Engine

Nicknamed "engine-q", the new engine grew from being a rewrite of parsing and evaluation logic into a full rewrite of Nushell itself. Done over 8 months, the final result has many improvements over the 0.44 engine.

## The new delta system

One powerful new aspect of the new engine is its delta system. Deltas, or change sets, let the engine stay immutable except at key phase shifts. For Nushell, after the user has hit enter in the repl, it will phase shift into parsing, then take a delta of what was given by the user. This delta may contain new definitions, new variables, new modules and more. This delta is merged into the permanent state inside of the engine. After this, the engine returns to being immutable as evaluation begins.

These discrete phase shifts make it possible to limit what mutates while maintaining flexibility, including the ability for users to write parallel code against the engine at any point of evaluation.

Mutation during evaluation isn't removed, instead it's isolated to the stack.

## Stacks, the site of change

For evaluation, stacks are now the site of change in the engine. Transient vectors that can be passed around during evaluation, changes to the environment, newly shadowed variables, and more are kept in stack.

## Closing over variables

Another important aspect of the engine and the new uses of stacks is that increased focus on correctness for how blocks work with stacks. In 0.60, we've eliminated many bugs related to variables scopes, where sometimes variables would "leak" from one scope to the next.

## Bind once, run anywhere

While improving the parser and engine, we also improved how the two connected to each other. One piece of this was all bindings, that is, how definition sites and use sites bind to one another. In the new engine, we use unique identifiers for all matter of definition in the engine, including variables, declarations, aliases, modules and more. During parse time, we bind the use we see against the definition in scope, and replace the use with a reference to the ID we found. With this, we can later safely export or pass the containing block without losing track of what the original code meant.

## Faster than ever before

The new engine's data representation is also quite a bit lighter than before. This allows us to evaluate scripts with less overhead. Early results are already quite positive:

- 1 million iteration tight loop
  - 0.44 - 626ms
  - 0.60 - 239ms

- Gradient drawing benchmark
  - 0.44 - 168ms
  - 0.60 - 78ms

# New plugin architecture

Rather that scanning for all new plugins on startup like we did with 0.44 (and taking ages to start Nu), the new `register` command stores the
location and signature of your plugins, making it easier to load at start up.

```
> register -e capnp ~/.cargo/bin/nu_plugin_extra_query
```

Also, the new plugin architecture is now multi-protocol, allowing you to pick the right protocol for your plugin. We currently support json and capnp.

By the way, you are not limited to write plugins in Rust. You can even create a python script and use it as a Nushell plugin. You only need to
specify what command should be used to run the plugin

```
> register -e json -s python ~/my_plugins/plugin.py
```

# Acknowledgements

A big "thank you!" to everyone who helped us build this version of Nushell!

```
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  0 â”‚ Access                          â”‚
â”‚  1 â”‚ adamijak                        â”‚
â”‚  2 â”‚ ahkrr                           â”‚
â”‚  3 â”‚ ammkrn                          â”‚
â”‚  4 â”‚ Andrew                          â”‚
â”‚  5 â”‚ Andrew Barnes                   â”‚
â”‚  6 â”‚ AndrÃ©s N. Robalino              â”‚
â”‚  7 â”‚ Antonio Natilla                 â”‚
â”‚  8 â”‚ Arthur                          â”‚
â”‚  9 â”‚ Arthur Targaryen                â”‚
â”‚ 10 â”‚ Ashish Thapa                    â”‚
â”‚ 11 â”‚ Basile Henry                    â”‚
â”‚ 12 â”‚ BenoÃ®t Cortier                  â”‚
â”‚ 13 â”‚ Chris Gillespie                 â”‚
â”‚ 14 â”‚ crozbo                          â”‚
â”‚ 15 â”‚ Daniel Reilly                   â”‚
â”‚ 16 â”‚ Darren Schroeder                â”‚
â”‚ 17 â”‚ David Lattimore                 â”‚
â”‚ 18 â”‚ DawnMagnet                      â”‚
â”‚ 19 â”‚ dependabot[bot]                 â”‚
â”‚ 20 â”‚ dgalbraith                      â”‚
â”‚ 21 â”‚ Dheepak Krishnamurthy           â”‚
â”‚ 22 â”‚ Ebuka Agbanyim                  â”‚
â”‚ 23 â”‚ eggcaker                        â”‚
â”‚ 24 â”‚ Eli Flanagan                    â”‚
â”‚ 25 â”‚ Fernando Herrera                â”‚
â”‚ 26 â”‚ Gabriel B Gutierrez             â”‚
â”‚ 27 â”‚ Gabriel Borges Gutierrez        â”‚
â”‚ 28 â”‚ Genna Wingert                   â”‚
â”‚ 29 â”‚ Guillermo Lella                 â”‚
â”‚ 30 â”‚ Hilmar GÃºstafsson               â”‚
â”‚ 31 â”‚ hustcer                         â”‚
â”‚ 32 â”‚ jacremer                        â”‚
â”‚ 33 â”‚ Jae-Heon Ji                     â”‚
â”‚ 34 â”‚ jaeheonji                       â”‚
â”‚ 35 â”‚ Jakub Å½Ã¡dnÃ­k                    â”‚
â”‚ 36 â”‚ Jason Hansen                    â”‚
â”‚ 37 â”‚ Jonathan Moore                  â”‚
â”‚ 38 â”‚ Joseph T. Lyons                 â”‚
â”‚ 39 â”‚ Josh                            â”‚
â”‚ 40 â”‚ JT                              â”‚
â”‚ 41 â”‚ Julian Aichholz                 â”‚
â”‚ 42 â”‚ Justin                          â”‚
â”‚ 43 â”‚ Justin Ma                       â”‚
â”‚ 44 â”‚ Kamil                           â”‚
â”‚ 45 â”‚ Kat MarchÃ¡n                     â”‚
â”‚ 46 â”‚ Leo Kettmeir                    â”‚
â”‚ 47 â”‚ LordMZTE                        â”‚
â”‚ 48 â”‚ Luca Trevisani                  â”‚
â”‚ 49 â”‚ Luccas Mateus                   â”‚
â”‚ 50 â”‚ Luccas Mateus de Medeiros Gomes â”‚
â”‚ 51 â”‚ Marco Zanrosso                  â”‚
â”‚ 52 â”‚ Mariano Guerra                  â”‚
â”‚ 53 â”‚ Matthew Auld                    â”‚
â”‚ 54 â”‚ Maxim Zhiburt                   â”‚
â”‚ 55 â”‚ Michael Angerman                â”‚
â”‚ 56 â”‚ Michael Rutter                  â”‚
â”‚ 57 â”‚ mzanrosso                       â”‚
â”‚ 58 â”‚ nibon7                          â”‚
â”‚ 59 â”‚ Niklas S                        â”‚
â”‚ 60 â”‚ Niklas Schoellhorn              â”‚
â”‚ 61 â”‚ onthebridgetonowhere            â”‚
â”‚ 62 â”‚ Onur Åžahin                      â”‚
â”‚ 63 â”‚ panicbit                        â”‚
â”‚ 64 â”‚ Ray Henry                       â”‚
â”‚ 65 â”‚ Reilly Wood                     â”‚
â”‚ 66 â”‚ Robert O'Shea                   â”‚
â”‚ 67 â”‚ sebastian-xyz                   â”‚
â”‚ 68 â”‚ Sherub Thakur                   â”‚
â”‚ 69 â”‚ sholderbach                     â”‚
â”‚ 70 â”‚ st155052                        â”‚
â”‚ 71 â”‚ Stefan Holderbach               â”‚
â”‚ 72 â”‚ Stefan Stanciulescu             â”‚
â”‚ 73 â”‚ Tanishq Kancharla               â”‚
â”‚ 74 â”‚ Tom Panton                      â”‚
â”‚ 75 â”‚ Urgau                           â”‚
â”‚ 76 â”‚ WindSoilder                     â”‚
â”‚ 77 â”‚ xiuxiu62                        â”‚
â”‚ 78 â”‚ Yutaro Ohno                     â”‚
â”‚ 79 â”‚ ZetaNumbers                     â”‚
â”‚ 80 â”‚ zkldi                           â”‚
â”‚ 81 â”‚ È˜tefan                          â”‚
â•°â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

# Looking ahead

---

NEEDS CLEANUP

---

some of the items are already documented pretty well. in this section maybe just supply a link to that section

- PROMPT_COMMAND and PROMPT_COMMAND_RIGHT are covered in coloring_and_theming.md
- LAST_EXIT_CODE is covered in stdout_stderr_exit_codes.md
- add screenshot for lscolors support - in assets folder with 0_59_1 prefix
- document parallelism and par-each - is documented in parallelism.md
- breaking changes is documented in this issue https://github.com/nushell/nushell/issues/4305 - maybe we should just put a link to this and maybe clean up that issue at the last moment before release and lock the issue?
- document people who've contributed passed 0.44


- footers in tables

insert 0_59_1_ls_sort.png

- `$env.LS_COLORS`

Nushell now respects your `LS_COLORS` environment variable if set. If it's not set, Nushell will provide a default 8-bit setting so people with color terminal can see file types in different colors as seen below in the following screenshots.

insert 0_59_1_ls_sort.png
insert 0_59_1_ls_gridc.png

- new commands in 0.60.0 (storm's table)

| category     | command                                         |
| ------------ | ----------------------------------------------- |
| conversions  | into {bool, datetime, duration}                 |
| core         | def-env, error make                             |
| core         | export_def_env, export_def, export env, export  |
| core         | extern, hide, metadata                          |
| core         | ignore, mod, module, register, use, view-source |
| env          | let_env, load_env, with-env                     |
| experimental | view_source                                     |
| filters      | columns, group, par-each, transpose, window     |
| formats      | nuon                                            |
| math         | reducers                                        |
| plugins      | gstat                                           |
| strings      | decode, nu-highlight, print                     |
| system       | complete                                        |
| viewers      | grid                                            |

### Questions ?

- ignore is in 0.44 but it is listed in the 0.60 blog post

### No new commands in the following categories ?

| category   | command |
| ---------- | ------- |
| date       | none    |
| filesystem | none    |
| generators | none    |
| hash       | none    |
| network    | none    |
| path       | none    |
| platform   | none    |
| random     | none    |
| shells     | none    |
